var documenterSearchIndex = {"docs":
[{"location":"methods/#Methods-list","page":"Methods","title":"Methods list","text":"","category":"section"},{"location":"methods/#Methods-usage","page":"Methods","title":"Methods usage","text":"","category":"section"},{"location":"methods/#MAT.matopen","page":"Methods","title":"MAT.matopen","text":"matopen(filename [, mode]; compress = false, table = MatlabTable) -> handle\nmatopen(f::Function, filename [, mode]; compress = false, table = MatlabTable) -> f(handle)\n\nMode defaults to \"r\" for read. It can also be \"w\" for write, or \"r+\" for read or write without creation or truncation.\n\nCompression on reading is detected/handled automatically; the compress keyword argument only affects write operations.\n\nUse with read, write, close, keys, and haskey.\n\nOptional keyword argument is the table type, for automatic conversion of Matlab tables. Note that Matlab tables may contain non-vector colums which cannot always be converted to a Julia table, like DataFrame.\n\nExample\n\nusing MAT, DataFrames\nfilepath = abspath(pkgdir(MAT), \"./test/v7.3/struct_table_datetime.mat\")\nfid = matopen(filepath; table = DataFrame)\nkeys(fid)\n\n# outputs\n\n1-element Vector{String}:\n \"s\"\n\n\nNow you can read any of the keys\n\ns = read(fid, \"s\")\nclose(fid)\ns\n\n# outputs\n\nDict{String, Any} with 2 entries:\n  \"testDatetime\" => DateTime(\"2019-12-02T16:42:49.634\")\n  \"testTable\"    => 3×5 DataFrame…\n\n\n\n\n\n\n","category":"function"},{"location":"methods/#MAT.matread-Tuple{AbstractString}","page":"Methods","title":"MAT.matread","text":"matread(filename; table = MatlabTable) -> Dict\n\nReturn a dictionary of all the variables and values in a Matlab file, opening and closing it automatically.\n\nOptionally provide the table type to convert Matlab tables into. Default uses a simple MatlabTable type.\n\nExample\n\nusing MAT, DataFrames\nfilepath = abspath(pkgdir(MAT), \"./test/v7.3/struct_table_datetime.mat\")\nvars = matread(filepath; table = DataFrame)\nvars[\"s\"][\"testTable\"]\n\n# outputs\n\n3×5 DataFrame\n Row │ FlightNum  Customer  Date                 Rating  Comment\n     │ Float64    String    DateTime             String  String\n─────┼─────────────────────────────────────────────────────────────────────────────────────\n   1 │    1261.0  Jones     2016-12-20T00:00:00  Good    Flight left on time, not crowded\n   2 │     547.0  Brown     2016-12-21T00:00:00  Poor    Late departure, ran out of dinne…\n   3 │    3489.0  Smith     2016-12-22T00:00:00  Fair    Late, but only by half an hour. …\n\n\n\n\n\n","category":"method"},{"location":"methods/#MAT.matwrite-Union{Tuple{T}, Tuple{S}, Tuple{AbstractString, AbstractDict{S, T}}} where {S, T}","page":"Methods","title":"MAT.matwrite","text":"matwrite(filename, d::Dict; compress::Bool = false, version::String = \"v7.3\")\n\nWrite a dictionary containing variable names as keys and values as values to a Matlab file, opening and closing it automatically.\n\n\n\n\n\n","category":"method"},{"location":"methods/#MAT.MAT_types.EmptyStruct","page":"Methods","title":"MAT.MAT_types.EmptyStruct","text":"Internal Marker for Empty Structs with dimensions like 1x0 or 0x0\n\n\n\n\n\n","category":"type"},{"location":"methods/#MAT.MAT_types.FunctionHandle","page":"Methods","title":"MAT.MAT_types.FunctionHandle","text":"FunctionHandle(d::Dict{String, Any}) <: AbstractDict{String, Any}\n\nType to store function handles which are stored as structs in MATLAB.\n\n\n\n\n\n","category":"type"},{"location":"methods/#MAT.MAT_types.MatlabClassObject","page":"Methods","title":"MAT.MAT_types.MatlabClassObject","text":"MatlabClassObject(\n    d::Dict{String, Any},\n    class::String,\n) <: AbstractDict{String, Any}\n\nType to store old class objects. Inside MATLAB a class named \"TestClassOld\" would be defined within @TestClassOld folders.\n\nIf you want to write these objects you have to make sure the keys in the Dict match the class defined properties/fields.\n\n\n\n\n\n","category":"type"},{"location":"methods/#MAT.MAT_types.MatlabOpaque","page":"Methods","title":"MAT.MAT_types.MatlabOpaque","text":"MatlabOpaque(\n    d::Dict{String, Any},\n    class::String,\n) <: AbstractDict{String, Any}\n\nType to store opaque class objects. These are the 'modern' Matlab classes, different from the old MatlabClassObject types.\n\n\n\n\n\n","category":"type"},{"location":"methods/#MAT.MAT_types.MatlabStructArray","page":"Methods","title":"MAT.MAT_types.MatlabStructArray","text":"MatlabStructArray{N}(\n    names::Vector{String},\n    values::Vector{Array{Any,N}},\n    class::String = \"\",\n)\n\nData structure to store matlab struct arrays, which stores the field names separate from the field values. The field values are stored as columns of Array{Any,N} per Matlab field, which is how MAT files store these structures.\n\nThese are distinct from cell arrays of structs, which are handled as in MAT.jl as Array{Any,N} with Dict{String,Any} inside, for example Any[Dict(\"x\"=>1), Dict(\"x\"=>2)].\n\nOld class object arrays can be handled by providing a non-empty class name.\n\nExample\n\nusing MAT\n\ns_arr = MatlabStructArray([\"a\", \"b\"], [[1, 2],[\"foo\", 5]])\n\n# write-read\nmatwrite(\"matfile.mat\", Dict{String,Any}(\"struct_array\" => s_arr))\nread_s_arr = matread(\"matfile.mat\")[\"struct_array\"]\n\n# convert to Dict Array\ndict_array = Array{Dict{String,Any}}(s_arr)\n\n# convert to Dict (with arrays as fields)\ndict = Dict{String,Any}(s_arr)\n\n\n\n\n\n","category":"type"},{"location":"object_arrays/#Objects-and-struct-arrays","page":"Object Arrays","title":"Objects and struct arrays","text":"To better handle special cases we have these types since MAT 0.11:\n\nMatlabStructArray\nMatlabClassObject","category":"section"},{"location":"object_arrays/#Struct-arrays-vs-Cell-arrays","page":"Object Arrays","title":"Struct arrays vs Cell arrays","text":"Cell arrays are written for Array{Any} or any other unsupported element type:\n\nsarr = Any[\n    Dict(\"x\"=>1.0, \"y\"=>2.0),\n    Dict(\"x\"=>3.0, \"y\"=>4.0)\n]\nmatwrite(\"matfile.mat\", Dict(\"cell\" => sarr))\n\n\nInside MATLAB you will find:\n\n>> load('matfile.mat')\n>> cell\n\ncell =\n\n  2×1 cell array\n\n    {1×1 struct}\n    {1×1 struct}\n\nRead and write behavior for struct arrays is different. For struct arrays we use the MatlabStructArray type. You can also write with MAT.jl using Dict arrays AbstractArray{<:AbstractDict} if all the Dicts have equal keys, which will automatically convert internally to MatlabStructArray.\n\nsarr = Dict{String, Any}[\n    Dict(\"x\"=>1.0, \"y\"=>2.0),\n    Dict(\"x\"=>3.0, \"y\"=>4.0)\n]\nmatwrite(\"matfile.mat\", Dict(\"s\" => sarr))\n# which is the same as:\nmatwrite(\"matfile.mat\", Dict(\"s\" => MatlabStructArray(sarr)))\n# which is the same as:\nmatwrite(\"matfile.mat\", Dict(\"s\" => MatlabStructArray([\"x\", \"y\"], [[1.0, 3.0], [2.0, 4.0]])))\n\nNow you'll find the following inside MATLAB:\n\n>> load('matfile.mat')\n>> s\n\ns =\n\n[2x1 struct, 576 bytes]\nx: 1\ny: 2\n\nNote that when you read the file again, you'll find the MatlabStructArray, which you can convert back to the Dict array with Array:\n\njulia> sarr = matread(\"matfile.mat\")[\"struct_array\"]\nMatlabStructArray{1} with 2 columns:\n \"x\": Any[1.0, 3.0]\n \"y\": Any[2.0, 4.0]\n\njulia> sarr[\"x\"]\n2-element Vector{Any}:\n 1.0\n 3.0\n\njulia> Array(sarr)\n2-element Vector{Dict{String, Any}}:\n Dict(\"x\" => 1.0, \"y\" => 2.0)\n Dict(\"x\" => 3.0, \"y\" => 4.0)\n\n\nNote that before v0.11 MAT.jl will read struct arrays as a Dict with concatenated arrays in the fields/keys, which is equal to Dict(sarr).","category":"section"},{"location":"object_arrays/#Object-Arrays","page":"Object Arrays","title":"Object Arrays","text":"You can write an old class object with the MatlabClassObject and arrays of objects with MatlabStructArray by providing the class name. These are also the types you obtain when you read files.\n\nPlease note that the order of the fields is important for MatlabClassObjects to be read properly in MATLAB. You may get Warning: Fields of object 'tc' do not match the current constructor definition for class 'TestClass'. The object has been converted to a structure.. Consider using OrderedDict if you have multiple fields.\n\nWrite a single class object:\n\nd = Dict{String,Any}(\"foo\" => 5.0)\nobj = MatlabClassObject(d, \"TestClass\")\nmatwrite(\"matfile.mat\", Dict(\"tc\" => obj))\n\nA class object array\n\nclass_array = MatlabStructArray([\"foo\"], [[5.0, \"bar\"]], \"TestClass\")\nmatwrite(\"matfile.mat\", Dict(\"class_array\" => class_array))\n\nAlso a class object array, but will be converted to MatlabStructArray internally:\n\nclass_array = MatlabClassObject[\n    MatlabClassObject(Dict{String,Any}(\"foo\" => 5.0), \"TestClass\"),\n    MatlabClassObject(Dict{String,Any}(\"foo\" => \"bar\"), \"TestClass\")\n]\nmatwrite(\"matfile.mat\", Dict(\"class_array\" => class_array))\n\nA cell array:\n\ncell_array = Any[\n    MatlabClassObject(Dict{String,Any}(\"foo\" => 5.0), \"TestClass\"),\n    MatlabClassObject(Dict{String,Any}(\"a\" => \"bar\"), \"AnotherClass\")\n]\nmatwrite(\"matfile.mat\", Dict(\"cell_array\" => cell_array))","category":"section"},{"location":"#MAT.jl-Documentation","page":"Home","title":"MAT.jl Documentation","text":"","category":"section"},{"location":"#Overview","page":"Home","title":"Overview","text":"This Julia package (MAT.jl) provides tools for reading and writing MATLAB format data files in Julia.","category":"section"},{"location":"#Basic-Usage","page":"Home","title":"Basic Usage","text":"To read a single variable from a MAT file (compressed files are detected and handled automatically):\n\nusing MAT\nfile = matopen(\"matfile.mat\")\nread(file, \"varname\") # note that this does NOT introduce a variable ``varname`` into scope\nclose(file)\n\nTo write a variable to a MAT file:\n\nfile = matopen(\"matfile.mat\", \"w\")\nwrite(file, \"varname\", variable)\nclose(file)\n\nTo read all variables from a MAT file as a Dict:\n\nvars = matread(\"matfile.mat\")\n\nTo write a Dict to a MAT file, using its keys as variable names. The compress argument is optional, and compression is off by default:\n\nmatwrite(\"matfile.mat\", Dict(\n\t\"myvar1\" => 0,\n\t\"myvar2\" => 1\n); compress = true)\n\nTo write in MATLAB v4 format:\n\nmatwrite(\"matfile.mat\", Dict(\n\t\"myvar1\" => 0,\n\t\"myvar2\" => 1\n);version=\"v4\")\n\nTo get a list of variable names in a MAT file:\n\nfile = matopen(\"matfile.mat\")\nvarnames = keys(file)\nclose(file)\n\nTo check for the presence of a variable name in a MAT file:\n\nfile = matopen(\"matfile.mat\")\nif haskey(file, \"variable\")\n    # something\nend\nclose(file)","category":"section"},{"location":"types/#Types-and-conversions","page":"Types","title":"Types and conversions","text":"MAT.jl uses the following type conversions from MATLAB types to Julia types:\n\nMATLAB Julia\nnumerical array Array{T}\ncell array Array{Any}\nchar array String\nstruct Dict{String,Any}\nstruct array MAT.MatlabStructArray\nold class object MAT.MatlabClassObject\nnew (opaque) class MAT.MatlabOpaque\n\nA few of the MatlabOpaque classes are automatically converted upon reading:\n\nMATLAB Julia\nstring String\ndatetime Dates.DateTime\nduration Dates.Millisecond\ncategory PooledArrays.PooledArray\ntable MAT.MatlabTable (or any other table)\n\nNote that single element arrays are typically converted to scalars in Julia, because MATLAB cannot distinguish between scalars and 1x1 sized arrays.","category":"section"}]
}
